# part1 函数式编程
# 什么是函数式编程
>## 函数式编程（Functional Programming,FP）,FP是编程范式之一

  * 面向对象编程的思维方式：把现实世界中的事物抽象成程序世界中的类和对象，通过封装、继承和多态来演示事物事件的联系
      * 函数式编程的思维方式：把现实世界的事物和事物之间的联系抽象到程序世界（对运算过程进行抽象）
      * 程序的本质：根据输入通过某种运算获得相应的输出，程序开发过程中会涉及很多有输入和输出的函数
      * X -> f(联系、映射) ->y , y=f(x)
      * ### 函数式编程中的函数指的不是程序中的函数（方法）,而是数学中的函数即映射关系，例如：y=sin(x),x和y的关系
      *相同的输入始终要得到相同的输出（纯函数）
      * 函数式编程用来描述数据（函数）之间的映射


>## 函数是一等公民
  * 函数可以存储在变量中
  * 函数作为参数
  * 函数作为返回值

>## 高阶函数
  * 可以把函数作为参数传递给另一个函数
  * 可以把函数作为另一个函数的返回结果 

>## 闭包
  * 可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员

>## 纯函数
  * 相同的输入永远会得到相同的输出，而且没有任何可观察的副作用
  * 数组的slice和splice 分别是纯哈桑农户和不纯的函数
        * slice 返回数组中指定部分，不会改变原数组
        * splice 对数组进行操作返回该数组，会改变原数组
  * 纯函数的好处
        * 可缓存：因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来（经常配合lodash中的memoize（记忆方法）方法）

>## 函数组合
  * 如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数
      * 函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道星成最终结果
      * 函数组合默认是从右到左执行 

>## Functor(函子)

  * 是一个特殊的容器，通过一个普通的对象来实现，该对象具有map方法，map方法可以运行一个函数对值进行处理

>## IO函子

  * 柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数
  * 是一种对函数参数的缓存
  * 让函数变得更灵活，让函数的粒度更小
  * 可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能
>## IO函子
  * IO函子中的_value是一个函数，这里是把函数作为值处理的
  * IO函子可以把不纯的动作存储到_value中，延迟执行这个不纯的操作（惰性执行）
  * 把不纯的操作交给调用者来处理

>## Task异步执行
  * folktale是一个标准的函数式变成库
      * 和lodash、remda不同的是，他没有提供很多功能函数 
      * 只提供了一些函数式处理的操作，例如：compose、curry等

>## Pointed函子
  * Pointed 函子是实现了of 静态方法的函子
  * of方法是为了避免使用new来创建对象，更深层的含义是of方法用来把值放到上下文Context（把值放到容器中，使用map来处理值）        

>## Monad 函子
  * 是一个可以变扁的Pointed 函子IO(IO(x))
  * 一个函子如果具有join和of两个方法并遵守一些定律就是一个Monad  

# 类型安全
  ## 强类型：强类型语言中不允许有任意的隐式类型转换
  ## 弱类型：允许有任意的隐式类型转换

# 类型系统
  ## 静态类型：一个变量声明时它的类型就是明确的，声明过后，它的类型不允许再修改
  ## 动态类型：运行阶段才能明确变量类型，变量的类型可以随时发生变化

>## 强类型优势
  * 错误更容易暴露
  * 代码更智能，编码更准确
  * 重构更牢靠
  * 减少不必要的类型判断  

>## 标准库
  * 标准库就是内置对象所对应的声明 

>## JS中的垃圾
  * Javascript 中内存管理是自动的
  * 后续代码如果通过引用关系无法再找到某些对象 
  * 对象不能从根上访问到时

>## JS中的可达对象
  * 可以访问到的对象（引用、作用域链）
  * 可达的标准就是从根出发是否能够被找到
  * js中的根就可以理解为全局变量对象
  
>## GC定义与作用
  * GC就是垃圾回收机制的简写
  * GC可以找到内存中的垃圾、并释放和回收空间

## 常见的GC算法
  >###  引用计数：设置引用数，判断当前引用数是否为0
  * ####  引用关系改变时修改引用数字
  * ####  引用数字为0时立即回收
  ###  优点
   * 发现垃圾时立即回收
   * 最大限度减少程序暂停
  ###  缺点
   * 无法回收循环引用的对象
   * 时间开销大
  >###  标记清除：分标记和清除两个阶段完成
    * ####  遍历所有对象找标记活动对象
    * ####  遍历所有对象清除没有标记对象
    * ####  回收相应的空间
  ###  优点
   * 相对于引用计数 解决了循环引用不能回收的问题
  ###  缺点
   * 产生空间碎片化，浪费空间
  >###  标记整理：是标记清除的增强
  * ####  标记阶段的操作和标记清除一致
  * ####  清除阶段会先执行整理，移动对象位置
  ###  优点
   * 减少碎片化空间
  ###  缺点
   * 不会立即回收垃圾对象
  >###  分代回收

## V8垃圾回收策略
  * 采用分代回收思想
  * 内存分为新生代、老生代
  * 针对不同对象采用不同算法

## V8中常见GC算法
  * 分代回收
  * 空间复制
  * 标记清除
  * 标记整理
  * 标记增量

## V8内存分配
  * V8内存空间一分为二
  * 小空间用于存储新生代对象（64位操作系统中是32M|32位操作系统中是16M），大空间用于存储老生代对象（64位操作系统1.4G，32位操作系统700M）
  * 新生代指的是存活时间较短的对象，老生代则是存活时间较长的对象
>###  新生代对象回收实现
  * 回收过程采用复制算法+标记整理
  * 新生代内存区分为两个等大小空间
  * 使用空间为From，空闲空间为To
  * 活动对象存储于From空间
  * 标记整理后将活动对象拷贝至To
  * From与To交换空间完成释放

>###  老生代对象回收实现
  * 主要采用标记清除、标记整理、增量标记算法（将垃圾回收标记分多段 从而使垃圾回收和程序执行交替执行）
  * 首先使用标记清除完成垃圾空间的回收
  * 采用标记整理进行空间优化
  * 采用增量标记进行效率优化

>###  新老对象回收细节对比
  * 新生代区域垃圾回收使用空间换时间
  * 老生代区域垃圾回收不适合复制算法

>###  V8总结
  * V8是一款主流的JS执行引擎
  * V8内存设置上限（1、主要为浏览器设计，上限内存足够应用。2、如果内存设计更大，垃圾回收时间就会超过用户感知）
  * V8采用基于分代回收思想实现垃圾回收
  * V8内存分为新生代和老生代

## 界定内存问题的标准
  * 内存泄露：内存使用持续升高
  * 内存膨胀：在多数设备上都存在性能问题
  * 频繁垃圾回收：通过内存变化图进行分析

>## 监控内存的几种方式
  * 浏览器任务管理器
  * TimeLine时序图记录
  * 堆快照查找分离DOM
  * 判断是否存在频繁的垃圾回收

>## 为什么确定频繁垃圾回收
  * GC工作时应用程序时停止的
  * 频繁且过长的GC会导致应用假死
  * 用户使用中感知应用卡顿


## 自动化
>## 自动化构建工作流：将开发阶段的源代码自动化构建成生产环境当中运行的代码
  * 脱离运行环境兼容带来的问题
  * 在使用提高效率的语法、规范和标准